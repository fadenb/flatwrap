#!/usr/bin/env bash
# flatwrap
# Generate and maintain executable launch wrappers for Flatpak apps.
#
# Overview
# - Creates wrapper executables in $HOME/.local/bin/flatpak-apps
# - Exposes both full Flatpak application IDs and short aliases (last dotted segment)
# - Resolves alias collisions with a stable 6 character hash suffix
# - Installs and manages systemd user units to auto sync on Flatpak changes
# - Adds WRAP_DIR to PATH via $HOME/.profile on first install
#
# Usage
#   flatwrap install     # Ensure PATH, write units, enable watchers and timer, sync now
#   flatwrap uninstall   # Disable units and remove them (wrappers left in place)
#   flatwrap sync        # Rebuild wrapper set from current Flatpak app list
#   flatwrap list        # List available wrapper commands
#   flatwrap help        # Show this help
#
# Requirements
# - bash, systemd --user, flatpak
# - One of: sha256sum, shasum, or openssl
#
# Notes
# - Wrappers forward all CLI arguments to "flatpak run <appid>"
# - Auto sync triggers on Flatpak export directory changes:
#     ~/.local/share/flatpak/exports/share/applications
#     /var/lib/flatpak/exports/share/applications
# - A periodic hourly timer provides a safety net
#
# Portability considerations
# - Uses only POSIX shell features plus bash builtins
# - Hashing supports sha256sum, shasum, or openssl for wider portability
# - Uses GNU find options commonly available on Ubuntu; adjust if targeting strict POSIX find

# shellcheck shell=bash
set -euo pipefail
IFS=$'\n\t'

WRAP_DIR="${HOME}/.local/bin"
SUFFIX="-flatwrap"
DRY_RUN="false"
SYSTEMD_DIR="${HOME}/.config/systemd/user"
SERVICE="${SYSTEMD_DIR}/flatwrap.service"
PATHUNIT="${SYSTEMD_DIR}/flatwrap.path"
TIMER="${SYSTEMD_DIR}/flatwrap.timer"

info() { printf '%s\n' "flatwrap: $*" >&2; }
die() { printf 'flatwrap: error: %s\n' "$*" >&2; exit 1; }

need() {
  command -v "$1" >/dev/null 2>&1 || die "missing dependency: $1"
}

# Append WRAP_DIR to PATH via .profile if not already present
ensure_path_export() {
  # Use ~/.local/bin (commonly already in PATH). Just ensure it exists.
  install -d "${WRAP_DIR}"
}

# Compute a short, stable suffix for an appid to break alias collisions
hash_suffix() {
  # Prefer sha256sum, fallback to shasum or openssl
  if command -v sha256sum >/dev/null 2>&1; then
    printf '%s' "$1" | sha256sum | cut -c1-6
  elif command -v shasum >/dev/null 2>&1; then
    printf '%s' "$1" | shasum -a 256 | cut -c1-6
  elif command -v openssl >/dev/null 2>&1; then
    printf '%s' "$1" | openssl dgst -sha256 -r | cut -c1-6
  else
    die "no SHA256 tool found (need sha256sum, shasum, or openssl)"
  fi
}

# Write a single wrapper file with provided target appid and desired path
write_wrapper() {
  # $1 = appid, $2 = wrapper_path_base (suffix is appended automatically)
  # Use default-empty expansions to avoid 'set -u' errors when arguments are missing.
  local appid="${1:-}"
  local out_base="${2:-}"
  local out="${out_base}${SUFFIX}"
  if [ "${DRY_RUN:-false}" = "true" ]; then
    printf 'DRY: would write %s\n' "${out}"
  else
    cat > "${out}" <<WRAP
#!/usr/bin/env bash
# Autogenerated by flatwrap for ${appid}
exec flatpak run ${appid} "\$@"
WRAP
    chmod 0755 "${out}"
  fi
}

# Build desired wrapper set from current Flatpak app list and prune stale entries
sync_wrappers() {
  need flatpak
  install -d "${WRAP_DIR}"

  # Accept optional --dry-run / -n as first arg
  if [ "${1:-}" = "--dry-run" ] || [ "${1:-}" = "-n" ]; then
    DRY_RUN="true"
    shift
  else
    DRY_RUN="false"
  fi

  local desired
  desired="$(mktemp)"
  # Capture the temp filename into the trap now so the trap does not refer to
  # a local variable that may be out of scope when the trap runs.
  # Install the EXIT trap with the concrete filename we've just created.
  TMPFILE="${desired}"
  cleanup() { rm -f -- "${TMPFILE}" || true; }
  trap cleanup EXIT

  # Enumerate installed Flatpak apps: "application<TAB>name"
  while IFS=$'\t' read -r appid _; do
    [ -n "${appid:-}" ] || continue

    local short
    short="${appid##*.}"
    short="$(printf '%s' "${short}" | tr '[:upper:]' '[:lower:]')"

    # Full ID wrapper (suffixed file)
    local id_base="${WRAP_DIR}/${appid}"
    write_wrapper "${appid}" "${id_base}"
    printf '%s\n' "${id_base}${SUFFIX}" >> "${desired}"

    # Short alias: prefer an un-suffixed symlink pointing to the suffixed wrapper when safe
    local alias_base="${WRAP_DIR}/${short}"
    local alias_suff="${alias_base}${SUFFIX}"

    if [ ! -e "${alias_base}" ]; then
      # write suffixed wrapper and create symlink
      write_wrapper "${appid}" "${alias_base}"
      if [ "${DRY_RUN}" = "true" ]; then
        printf 'DRY: would symlink %s -> %s\n' "${alias_base}" "${alias_suff}"
      else
        ln -sf -- "${alias_suff}" "${alias_base}"
      fi
      printf '%s\n' "${alias_suff}" >> "${desired}"
      printf '%s\n' "${alias_base}" >> "${desired}"
    else
      # If un-suffixed is a symlink already pointing to our suffixed file, update it
      if [ -L "${alias_base}" ] && [ "$(readlink -f "${alias_base}")" = "${alias_suff}" ]; then
        write_wrapper "${appid}" "${alias_base}"
        printf '%s\n' "${alias_suff}" >> "${desired}"
        printf '%s\n' "${alias_base}" >> "${desired}"
      else
        # Collision: write a hashed suffixed wrapper (no un-suffixed symlink)
        local suf
        suf="$(hash_suffix "${appid}")"
        local alias_hashed_base="${WRAP_DIR}/${short}-${suf}"
        write_wrapper "${appid}" "${alias_hashed_base}"
        printf '%s\n' "${alias_hashed_base}${SUFFIX}" >> "${desired}"
        # Inform the user that we couldn't create the plain alias and created a hashed alias instead
        if [ "${DRY_RUN}" = "true" ]; then
          printf 'DRY: collision: would create hashed alias %s (original %s exists)\n' "${alias_hashed_base}${SUFFIX}" "${alias_base}" >&2
        else
          printf 'flatwrap: collision: could not use alias "%s"; created "%s" instead\n' "${alias_base##*/}" "${alias_hashed_base##*/}${SUFFIX}" >&2
        fi
      fi
    fi
  done < <(flatpak list --app --columns=application,name)

  # Prune managed files: suffixed files and symlinks pointing to them.
  # Remove suffixed files not in desired
  while IFS= read -r -d '' f; do
    if ! grep -Fxq "${f}" "${desired}"; then
      if [ "${DRY_RUN}" = "true" ]; then
        printf 'DRY: would remove %s\n' "${f}"
      else
        rm -f -- "${f}"
      fi
    fi
  done < <(find "${WRAP_DIR}" -maxdepth 1 -type f -name "*${SUFFIX}" -print0)

  # Remove symlinks we created that are no longer desired
  # IMPORTANT: only consider symlinks that point to a target with our SUFFIX.
  # Never remove symlinks that do not target a managed suffixed file.
  while IFS= read -r -d '' l; do
    target="$(readlink -f "${l}")" || target=""
    # Only manage symlinks that point to files whose basename ends with SUFFIX
    tbase="$(basename "${target}" 2>/dev/null || true)"
    case "${tbase}" in
      *"${SUFFIX}")
        # ok: this symlink points to a managed suffixed file
        ;;
      *)
        # not managed by us; skip
        continue
        ;;
    esac

    if ! grep -Fxq "${l}" "${desired}" && ! grep -Fxq "${target}" "${desired}"; then
      if [ "${DRY_RUN}" = "true" ]; then
        printf 'DRY: would remove symlink %s -> %s\n' "${l}" "${target}"
      else
        rm -f -- "${l}"
      fi
    fi
  done < <(find "${WRAP_DIR}" -maxdepth 1 -type l -print0)
}

# Write systemd user units with inline documentation
write_units() {
  install -d "${SYSTEMD_DIR}"

  # Service unit: the action triggered by path or timer
  cat > "${SERVICE}" <<'SVC'
[Unit]
Description=flatwrap sync (generate Flatpak launch wrappers)
Documentation=man:flatpak(1)
# Rebuilds wrapper executables under ~/.local/bin/flatpak-apps

[Service]
Type=oneshot
ExecStart=%h/.local/bin/flatwrap sync
SVC

  # Path unit: triggers on Flatpak export directory changes (install/update/remove)
  cat > "${PATHUNIT}" <<'PAT'
[Unit]
Description=flatwrap trigger on Flatpak export changes
# Watches both user and system export dirs written by Flatpak

[Path]
PathChanged=%h/.local/share/flatpak/exports/share/applications
PathChanged=/var/lib/flatpak/exports/share/applications

[Install]
WantedBy=default.target
PAT

  # Timer unit: periodic safety net in case an event is missed
  cat > "${TIMER}" <<'TMR'
[Unit]
Description=flatwrap periodic sync (hourly)
# Provides eventual consistency

[Timer]
OnBootSec=300
OnUnitActiveSec=3600
Persistent=true

[Install]
WantedBy=timers.target
TMR

  systemctl --user daemon-reload
}

enable_units() {
  systemctl --user enable --now flatwrap.path
  systemctl --user enable --now flatwrap.timer
}

disable_units() {
  systemctl --user disable --now flatwrap.path || true
  systemctl --user disable --now flatwrap.timer || true
}

cmd_install() {
  need systemctl
  ensure_path_export
  write_units
  enable_units
  sync_wrappers
  info "installed and synced; wrappers under ${WRAP_DIR}"
}

cmd_uninstall() {
  need systemctl
  disable_units
  rm -f -- "${SERVICE}" "${PATHUNIT}" "${TIMER}"
  systemctl --user daemon-reload
  info "units removed; wrappers remain in ${WRAP_DIR}"
}

cmd_list() {
  install -d "${WRAP_DIR}"
  # Build a user-friendly list of commands we manage.
  # Prefer showing the un-suffixed alias when present; otherwise show the suffixed name without SUFFIX.
  local -a out
  out=()

  # Iterate suffixed managed files
  while IFS= read -r -d '' f; do
    base="$(basename "${f}")"
    # remove suffix
  name_no_suf="${base%"${SUFFIX}"}"

    # If this name_no_suf looks like a full appid (contains a dot), also consider the short alias
    if [[ "${name_no_suf}" == *.* ]]; then
      short="${name_no_suf##*.}"
      short="$(printf '%s' "${short}" | tr '[:upper:]' '[:lower:]')"
      alias_path="${WRAP_DIR}/${short}"
      if [ -e "${alias_path}" ]; then
        # Show the alias name
        out+=("${short}")
        out+=("${name_no_suf}")
        continue
      fi
    fi

    # Otherwise show the stripped name (could be full appid or hashed alias)
    out+=("${name_no_suf}")
  done < <(find "${WRAP_DIR}" -maxdepth 1 -type f -name "*${SUFFIX}" -print0)

  # Deduplicate and sort
  if [ ${#out[@]} -gt 0 ]; then
    printf '%s\n' "${out[@]}" | awk '!seen[$0]++' | sort
  fi
}

cmd_help() {
  sed -n '1,140p' "$0" | sed -n '1,/^set -euo pipefail/p'
  printf '\nCommands:\n  install\n  uninstall\n  sync\n  list\n  help\n'
}

main() {
  case "${1:-}" in
    install)   shift; cmd_install "$@";;
    uninstall) shift; cmd_uninstall "$@";;
    sync)      shift; sync_wrappers "$@";;
    list)      shift; cmd_list "$@";;
    help|-h|--help) cmd_help;;
    *) die "unknown command: ${1:-<none>} (try: flatwrap help)";;
  esac
}

main "$@"
